# H3 - No strings attached

Tehtävänannot luettavissa https://terokarvinen.com/application-hacking/

A-kohdassa käytetty laitteisto:
 ````
Isäntälaite: Macbook Pro
 Käyttöjärjestelmä: macOS Sequoia 15.1
 Prosessori: M1 Pro (Apple silicon)
 RAM: 16GB

Virtuaalikoneen tiedot:
 OS: Debian 12 Bookworm
 RAM: 4GB 
 Virtualisointi: UTM
````

Muut tehtävät:
````
Asus Vivobook X1501
OS: Kali 2024.3 (kali-rolling)
RAM: 16GB
CPU: 12th Gen Intel(R) Core(TM) i7-1255u (x86_64)
````


## A) Strings

Latasin ``$ https://terokarvinen.com/loota/yctjx7/ezbin-challenges.zip`` ja purin ``$ unzip ezbin-challenges.zip`` tehtäväpaketin. Siirryin hakemistoon komennoilla ``$ cd challenges; cd passtr``. Hakemistosta löytyi README.md-tiedosto, jonka luin komennolla ``$ cat README.md``. 

Ohjeissa suositeltiin uudelleenkokoamaan binääri, jos käytössä on ARM64-arkkitehtuurin laite, joka tehtävien tekemiseen käyttämäni MacBook on. Ajoin ohjeiden mukaiset komennot ``$ make clean`` ja ``$ make``. 

 - ``$ make clean`` näytti poistavan jo kootun binäärin (tulosti ``rm -f passtr``)
 - ``$ make`` kokosi sen uudelleen (tulosti ``gcc passtr.c -o passtr``)

Näiden jälkeen testasin, mitä ohjelma tekee käynnistämällä sen komennolla ``$ ./passtr``, joka ajaa työhakemistosta binäärin passtr. Ohjelma kysyy salasanaa, jonka syöttämisen jälkeen kertoo oliko arvaus oikea.

![!Add file: no bonus](/img/h3/passtr_no_bonus.png)
> Ei voittoa :(

Tehtävässä oli tarkoitus selvittää salasana lukematta lähdekoodin binääriä. Kotitehtävien vihjeosiossa kehotettiin käyttämään strings-ohjelmaa. Ohjelma ei ollut minulle ennestään tuttu, joten silmäilin nopeasti ``$ man strings``-komennolla aukeavan manuaalin läpi.

Manpagesin pohjalta lyhyt yhteenveto strings käytöstä:
 - ``$ strings [parametrit] [tiedosto]``: etsii ja tulostaa ihmisen luettavissa olevia merkkijonoja tiedostosta
 - ``-n``: merkkijonon minimipituuden määrittely, esim 4 (tavua/merkkiä)
 - ``-a``: pakottaa stringsin käymään koko tiedoston läpi (oletusasetus)
 - ``-f``: näyttää tiedostonimen tulostuksen jokaisella rivillä

Testasin etsimällä binääristä yli 4 merkin pituiset merkkijonot, ja tulostamaan muodon vuoksi tiedostonimen jokaiselle riville:
````
$ strings -n 4 -f passtr
passtr: /lib/ld-linux-aarch64.so.1
[...]
passtr: What's the password?
passtr: %19s
passtr: sala-hakkeri-321
passtr: Yes! That's the password. FLAG{Tero-d75ee66af0a68663f15539ec0f46e3b1}
passtr: Sorry, no bonus.
[...]
passtr: .comment
````
> Karsittu tuloste. 'passtr:' rivin alussa on skannatun tiedoston nimi, jonka perässä selkokielistä tekstiä binääristä.

Tulosteesta löytynyt sala-hakkeri-321 vaikutti lupaavalta, joten tarjosin sitä passtr:lle.

````
$ ./passtr 
What's the password?
sala-hakkeri-321
Yes! That's the password. FLAG{Tero-d75ee66af0a68663f15539ec0f46e3b1}
````
> Voittava arpa!

## B) passtr.c obfuskointi

Salasanan tallentaminen selkokielisenä suoraan koodiin ei vaikuttanut kovin turvalliselta tavalta kehittää ohjelmia. Tehtävässä piti saada se piilotettua binääristä esimerkiksi obfuskoinnin avulla. En ole juurikaan koodia kirjoitellut, joten obfuskoinnin maailma oli itselleni täysin tuntematon. 

Aloitin syventämällä ymmärrystäni siitä, mitä obfuskointi tarkoittaa. Googlen kautta päädyin [asee:n](https://cybersecurity.asee.io/code-obfuscation/) artikkeliin obfuskoinnista. Olennaisilta vaikuttaneet kohdat tiivistettynä:

 - Obfuskoinnin tarkoituksena on tehdä koodista vaikealukuisempaa vaikuttamatta sen toiminnallisuuteen
 - Tekniikoita mm.:
   - Metodien ja muuttujien uudelleennimeäminen 
   - Pakkaaminen
   - Turhan dummy-koodin lisääminen
   - Merkkijonojen kryptaaminen
 - Valituista tekniikoista riippuen vaikuttaa koodin suoritusnopeuteen 0-80%
   - Uudelleennimeäminen ei juuri vaikuta suoritukseen
   - Ylimääräisen koodin lisäämisellä suuremmat vaikutukset [1]

Pakkaaminen vaikutti alkuun kätevältä tavalta obfuskoida valmista koodia. Kysyin ChatGPT:ltä suositukset: ``Suosittele minulle Linuxilla ajettavaa vapaan lähdekoodin ohjelmaa valmiin binäärin obfuskointiin.``. Tekoäly-ystävämme listasi neljä vaihtoehtoa, Obfuscator-LLVM, UPX, Tiger compiler(tigress) ja Ollvm [2]. UPX on kuulemma hyvä perusvaihtoehto yksinkertaiseen suojaustasoon, joten valitsin sen. Päädyin [UPX:n](https://upx.github.io/) sivuille, josta latasin tuoreimman version: ``$ wget https://github.com/upx/upx/releases/download/v4.2.4/upx-4.2.4-amd64_linux.tar.xz``. Purin paketin ``$ tar -xf upx-4.2.4-amd64_linux.tar.xz``, siirryin tämän seurauksena luotuun hakemistoon ``$ cd upx-4.2.4-amd64_linux`` ja listasin hakemiston tiedostot ``$ ls``. 

Hakemistossa yli yksi ajettava binääri, upx. En halunnut pyöritellä ohjelmaa siirtymällä aina tuohon hakemistoon, joten loin siitä kaikkien käytettävissä olevan kopion ``$ sudo cp upx /usr/local/bin/``. Tämän jälkeen testasin, että komento toimii myös muissa hakemistoissa siirtymässä passtr:n hakemistoon ja ajamalla komennon ``$ upx``.

![Add file: UPX](/img/h3/upx.png)
> Toimii!


 
[1] asee: What is code obduscation? Luettavissa https://cybersecurity.asee.io/code-obfuscation/

[2] OpenAI: ChatGPT. https://chatgpt.com/

## C) packd

## D) Cryptopals 1-4

## Lähteet

Karvinen, 2024. https://terokarvinen.com/application-hacking/

asee: What is code obduscation? Luettavissa https://cybersecurity.asee.io/code-obfuscation/. Luettu 9.11.2024.

