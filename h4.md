# H4 - Kääntöpaikka

Tehtävänannot luettavissa https://terokarvinen.com/application-hacking/

## X) Lue/katso ja tiivistä

### John Hammond - GHIDRA for Reverse Engineering (PicoCTF 2022 #42 'bbbloat')

Videolla Hammond ratkaisee PicoCTF:n tehtävän Bbbbloat.

 - Ennen Ghidran käyttöä voi kokeilla ``$ ltrace``, ``$ strace``, ``$ objdump -d``, ``$ file``
   - Debuggerin tapaisia ohjelmia
   - ltrace seuraa ajonaikaisia kirjastojen kutsuja
   - strace seuraa systeemikutsuja
 - Ghidran asennus:
   - Lataus Githubista
   - Purku (``$ unzip [tiedosto]``)
   - Tarvittaessa javan asennus 
 - Ghidran käyttö:
   - Luo uusi projekti
   - Lisää analysoitava binääri projektille
   - Analyze? -> yes
 - Videolla hyödynnettyjä Ghidran ominaisuuksia:
   - Window -> defined strings: etsii merkkijonoja
   - L: rename (pikanäppäin)
 - Assembler:
   - XREF: Cross-reference. Viittaus muuttujaan tai funktioon
   - FUN: funktio
   - LEA: Load effective address

Hammond tulkitsee ohjelman lähdekoodista, mihin arvoon käyttäjän syötettä verrataan. Arvo on koodissa heksadesimaaliarvona, jonka desimaaliksi muuttamalla ja syöttämällä tehtävään lippu paljastuu. 

Lähde: https://www.youtube.com/watch?v=oTD_ki86c9I


## A) Ghidran asennus

Asensin Ghidran jo edellisellä tunnilla, mistä johtuen prosessi kirjoitettu pitkälti ulkomuistista.

Vaiheet:
 - Latasin GitHubista Ghidran tuoreimman julkaisun: ``$ wget https://github.com/NationalSecurityAgency/ghidra/releases/download/Ghidra_11.2.1_build/ghidra_11.2.1_PUBLIC_20241105.zip``
 - Purin .zip-tiedoston: ``$ unzip ghidra_11.2.1_PUBLIC_20241105.zip``
 - Siirryin paketin purkamisesta luotuun hakemistoon ja ajoin Ghidran: ``$ ./ghidraRun``
   - Käynnistäminen epäonnistui Java-version yhteensopimattomuuden takia.
   - Asensin tuoreemmat versiot Javasta ``$ sudo apt-get install default-jre default-jdk``
     - ``$ javac --version # javac 21.0.5``
 - Tämän jälkeen Ghidran käynnistys onnistui komennolla ``$ ./ghidraRun``

## B) Rever-C

Aloitin purkamalla(``$ unzip ezbin-challenges.zip``) [tehtävänantoon](https://terokarvinen.com/application-hacking/) linkatun binääripaketin, jonka sisältämiä ohjelmia tehtävissä oli tarkoitus tutkia Ghidralla. Tämän jälkeen loin Ghidraan uuden projektin (Ctrl + N), johon lisäsin tiedoston packd. Tiedoston lisäämisen jälkeen Ghidra näytti yhteenvedon lisätystä tiedostosta.

![Add file: new project](/img/h4/packd_info.png)
> Packd:n yhteenveto

Avasin projektiin lisätyn packd-tiedoston tuplaklikkaamalla sitä. Ghidra kysyi halutaanko tiedosto analysoida, ja painoin kyllä. En tehnyt muutoksia analysoinnin vakioasetuksiin. Packd on obfuskoitu pakkaamalla, mistä johtuen Ghidra ei saanut siitä kovin helppolukuista C-koodia pihalle. Eniten main()-funktiolta vaikutti tämä FUN_001054d0, josta ei kuitenkaan saa juuri mitään irti:

````
undefined8 FUN_001054d0(void)

{
  int iVar1;
  undefined local_28 [32];
  
  FUN_001053a7(0x10637f);
  FUN_001053c7(0x106394,local_28);
  iVar1 = FUN_001053b7(local_28,0x106399);
  if (iVar1 == 0) {
    FUN_001053a7(0x1063a7);
  }
  else {
    FUN_001053a7(0x1063ed);
  }
  return 0;
}
````
> Vaikeaselkoista on pakatulla binäärillä

Loin packd:n binääristä kopion, josta purin salauksen UPX:llä komennolla ``$ upx -d packd_d``. Sisäsin tämänkin tiedoston projektille, analysoin sen ja Ghidra sai jo huomattavasti järkevämmän näköisen koodin siitä pihalle:

![Add file: packd_d](/img/h4/packd_d_analyzed.png)
> Näyttää paremmalta

Kuvassa vasemmalla alhaalla olevan Symbol Treen alta löytyivät Ghidran tunnistamat funktiot, joista isoimpaan decompile-ikkunaan on avattu main. 

````
undefined8 main(void) //palauttaa lopuksi 0, joten main-funktion tyyppi oletettavasti int

{
  int iVar1; //
  char local_28 [32]; 
  
  puts("What\'s the password?");
  __isoc99_scanf(&DAT_0010201d,local_28); //salasanan syöttö ja tallentaminen local_28-muuttujaan
  iVar1 = strcmp(local_28,"piilos-AnAnAs"); //iVar1 laskee eroja merkkijonoista local_28 ja piilos-AnAnAs
  if (iVar1 == 0) { // ei eroja paljastaa lipun
    puts("Yes! That\'s the password. FLAG{Tero-0e3bed0a89d8851da933c64fefad4ff2}");
  }
  else {
    puts("Sorry, no bonus.");
  }
  return 0; 
}
````

Muokkasin ohjelman koodia:
 - ``undefined 9 main(void)`` --> ``int main(void)``
 - ``int iVar1`` --> ``int difference``
 - ``char local_28`` --> ``char input``

Nyt koodi oli jo kohtuullisen helppolukuista:

````
int main(void)

{
  int difference;
  char input [32];
  
  puts("What\'s the password?");
  __isoc99_scanf(&DAT_0010201d,input);
  difference = strcmp(input,"piilos-AnAnAs");
  if (difference == 0) {
    puts("Yes! That\'s the password. FLAG{Tero-0e3bed0a89d8851da933c64fefad4ff2}");
  }
  else {
    puts("Sorry, no bonus.");
  }
  return 0;
}
````

Ohjelma siis kysyy salasanaa ja tallentaa syötetyn merkkijonon muuttujaan ``input``. Tämän jälkeen ``input``-muuttujaa vertaillaan merkki kerrallaan merkkijonoon "piilos-AnAnAs", ja erojen lukumäärä tallennetaan muuttujaan ``difference``. Jos eroja ei ole, tulostetaan lippu.

Oli aika testata, toimiiko ohjelma. File -> Export Program kautta sain tallennettua muokatun ohjelman. Valitsin Format-kentästä tiedoston muodoksi "Original file" ja tallensin sen eri hakemistoon, kuin alkuperäisen tiedoston.

![Add file: packd export](/img/h4/packd_export.png)
> Yhteenveto viennistä

Lopuksi testiin, että ohjelma vielä toimii. Ajoin Ghidralla muokatun tiedoston ``$ ./packd_d``. Ensimmäisellä yrityksellä tiedoston ajaminen epäonnistui puuttuvien oikeuksien takia. Lisäsin nämä ``$ chmod u+x packd_d``. Tämä antoi käyttäjälle(u) oikeuden ajaa(+x) tiedoston packd_d.

![Add file: packd_d testi](/img/h4/packd_testi.png)
> Toimii!

## C) Jos väärinpäin

Aloitin lisäämällä edellisessä tehtävässä luomalleni projektille passtr:n binäärin, minkä jälkeen avasin ja analysoin sen vakioasetuksilla. 

Ohjelman toimintaperiaate oli käytännössä sama, kuin edellisessä tehtävässä. Nimesin main-funktion muuttujat uudestaan, minkä jälkeen koodi näytti tältä:

````
int main(void)

{
  int difference;
  char input [32];
  
  puts("What\'s the password?");
  __isoc99_scanf(&DAT_0010201d,input);
  difference = strcmp(input,"sala-hakkeri-321");
  if (difference == 0) {
    puts("Yes! That\'s the password. FLAG{Tero-d75ee66af0a68663f15539ec0f46e3b1}");
  }
  else {
    puts("Sorry, no bonus.");
  }
  return 0;
}
````

Ohjelma piti saada hyväksymään kaikki muut, paitsi oikean salasanan. Käytännössä se onnistuu kääntämällä if-silmukan vaihtoehdot toisin päin. Se onnistuisi näin simppelissä tehtävässä itsekin koodia käsin muokkaamalla, mutta Ghidralla näiden kääntäminen onnistuu myös tekemällä muutoksia assembleriin. 

Etsin listing-työkalusta koodin kohdan, jossa syötettä vertaillaan salasanaan:

![Add file: passtr assembler](/img/h4/passtr_assembler.png)
> Koodin if-silmukka ja sitä vastaava assembler korostettuna

Muokkaamalla JNZ (jump if not zero) tilalle JZ (jump if zero), if-silmukan toiminta kääntyy päinvaistaiseksi. Tämä onnistui valitsemalla right-clickaamalla JNZ ja valitsemalla Patch instruction. Ghidra analysoi tilannetta hetken ja antoi muokkauksille hyvät onnistumismahdollisuudet. Main-funktion if muutoksen jälkeen:

````
  if (difference == 0) {
    puts("Sorry, no bonus.");
  }
  else {
    puts("Yes! That\'s the password. FLAG{Tero-d75ee66af0a68663f15539ec0f46e3b1}");
  }
````
> Silmukan tulosteet käännetty

Lopuksi exporttasin muokatun ohjelman, annoin käyttäjälle suoritusoikeudet ja testasin toiminnan.

![Add file: passtr testi](/img/h4/passtr_testi.png)
> Toimii halutulla tavalla

## D) Nora CrackMe

## E) Nora crackme01

## E) Nora crackme01e

## F) Nora crackme02

## G) Vapaaehtoinen: Nora crackme01 muut ratkaisut

## H) Vapaaehtoinen: Nora crackme02 toinen ratkaisu

## I) Vapaaehtoinen: Nora crackme02e 



## Lähteet

Karvinen 2024: Application Hacking. Luettavissa https://terokarvinen.com/application-hacking/. 

John Hammond - GHIDRA for Reverse Engineering (PicoCTF 2022 #42 'bbbloat'). Katsottavissa https://www.youtube.com/watch?v=oTD_ki86c9I. 

